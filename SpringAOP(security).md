스프링 AOP
-
보안 검사를 컨트롤러 중간에 놓는 것은 옳지 않다.  
왜냐하면, 수십~수백개에 달하는 컨트롤러에 중복된 코드를 사용하게 되기 때문이다.   
따라서 보안 검사는 중앙에서 담당하는 것이 옳다.  
중앙에서 담당한다면, API핸들러(여기선 컨트롤러)에 도달했을 때 부턴 더이상 보안에 대해 걱정하지 않아도 된다.

참고 : 
* 보안 검사를 수행하는데에는 몇가지 유형이 있다.
   1. 특정 IP 주소에서 오는 요청만 허용하는 방법
   2. 코드에 자격증명하는 코드를 하드코딩하는 방법
   3. 클라이언트 측에서 자격증명을 요청한 헤더에 포함시키게 하는 방법(Authorization 헤더)

왜 AOP를 사용해야하는가?
-
요청에 대해 보안 검사를 담당하는 SecurityFilter를 생성할 수 있다.  
이는 필터 내부에서 request.getRequestURI()와 request.getMethod로 요청이 어떤 API를 대상으로 하는 것인지 파악한 후 승인하는 방법이다.  
허나 이는 **요청을 처리하는 단계에서 보안검사를 원할 때만** 완벽하게 작동한다. 

복잡한 애플리케이션의 경우 메소드 단계에서 보안검사를 수행하기 원할 수 있다.  
이 경우 Filter 에서 넣어놓은 보안은 작동하지 않을 것이다.  
AOP는 OOP와 비교했을 때 애플리케이션 구조를 바라보는 또 다른 관점이라고 할 수 있다.  


관심사란?
-
어플리케이션이 충족해야하는 목표 중 하나
AOP에서 보안 검사는 보안에 관련된 관심사(Concerns) 이다.  
어플리케이션에서 관심사의 유형으로는 성능로깅, 트랜젝션 관리 등등이 있다.

애스팩트(Aspects)란?
-
애스팩트는 관심사들을 모듈화 한 것이다.  
여러 클래스에 걸쳐 코드를 분산하는 대신에 관심사를 다루는 로직을 하나의 애스팩트에 넣는다.   
스프링 AOP에서는 일반 클래스에 애스팩트를 구현 한 뒤에 AspectJ 라이브러리의 어노테이션인 @Aspect 를 적용하면 애스팩트가 된다.

ClassA의 methodA(), ClassB의 methodB(), ClassC의 methodC()가 있고 이 메소드 내부에서 보안검사가 필요하다고 가정하자.   
AOP 사용전에는 모든 메소드에 보안 검사를 처리하는 코드를 추가해야하나 AOP를 이용하면 보안검사로직을 자바 일반 클래스인 SecurityChecker 애스펙트로에서 해당 메소드를 뽑아내면 된다.  
그리고 이 클래스 내부에서 @Around 어노테이션을 추가해서 보안을 실행하는 시점을 지정할 수 있다.

구조도는 아래와 같다.

![AOP 구조도](./src/main/resources/image/aopStructure.png)
---

조인 포인트
-
AOP 에서 조인포인트(Join Points)는 특정 프로그램이 실행되는 지점이다.
여기서는 methodA(), methodB(), methodC() 가 그 지점에 해당된다.
